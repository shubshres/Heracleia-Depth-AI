import depthai.node as node
import typing
import json
from typing import Any, Callable, ClassVar, Dict, Iterator, List, Optional, Tuple

from typing import overload
import Calculation method used to obtain spatial locations
import Number of fractional bits for subpixel mode
import datetime
import numpy
X_LINK_ANY_PLATFORM: XLinkPlatform
X_LINK_ANY_PROTOCOL: XLinkProtocol
X_LINK_ANY_STATE: XLinkDeviceState
X_LINK_BOOTED: XLinkDeviceState
X_LINK_BOOTLOADER: XLinkDeviceState
X_LINK_FLASH_BOOTED: XLinkDeviceState
X_LINK_IPC: XLinkProtocol
X_LINK_MYRIAD_2: XLinkPlatform
X_LINK_MYRIAD_X: XLinkPlatform
X_LINK_NMB_OF_PROTOCOLS: XLinkProtocol
X_LINK_PCIE: XLinkProtocol
X_LINK_TCP_IP: XLinkProtocol
X_LINK_UNBOOTED: XLinkDeviceState
X_LINK_USB_CDC: XLinkProtocol
X_LINK_USB_VSC: XLinkProtocol

class ADatatype:
    def __init__(self, *args, **kwargs) -> None: ...
    def getRaw(self) -> RawBuffer: ...

class Asset:
    alignment: int
    data: numpy.ndarray[numpy.uint8]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @property
    def key(self) -> str: ...

class AssetManager:
    def __init__(self) -> None: ...
    def addExisting(self, assets: List[Asset]) -> None: ...
    @overload
    def get(self, key: str) -> Asset: ...
    @overload
    def get(self, key: str) -> Asset: ...
    @overload
    def getAll(self) -> List[Asset]: ...
    @overload
    def getAll(self) -> List[Asset]: ...
    def remove(self, key: str) -> None: ...
    @overload
    def set(self, asset: Asset) -> Asset: ...
    @overload
    def set(self, key: str, asset: Asset) -> Asset: ...
    @overload
    def set(self, key: str, path: str, alignment: int = ...) -> Asset: ...
    @overload
    def set(self, key: str, data: List[int], alignment: int = ...) -> Asset: ...
    def size(self) -> int: ...

class Buffer(ADatatype):
    def __init__(self) -> None: ...
    def getData(self) -> numpy.ndarray[numpy.uint8]: ...
    @overload
    def setData(self, arg0: List[int]) -> None: ...
    @overload
    def setData(self, arg0: numpy.ndarray[numpy.uint8]) -> None: ...

class CalibrationHandler:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: str) -> None: ...
    @overload
    def __init__(self, arg0: EepromData) -> None: ...
    def eepromToJsonFile(self, destPath: str) -> bool: ...
    def getBaselineDistance(self, cam1: CameraBoardSocket = ..., cam2: CameraBoardSocket = ..., useSpecTranslation: bool = ...) -> float: ...
    def getCameraExtrinsics(self, srcCamera: CameraBoardSocket, dstCamera: CameraBoardSocket, useSpecTranslation: bool = ...) -> List[List[float]]: ...
    @overload
    def getCameraIntrinsics(self, cameraId: CameraBoardSocket, resizeWidth: int = ..., resizeHeight: int = ..., topLeftPixelId: Point2f = ..., bottomRightPixelId: Point2f = ...) -> List[List[float]]: ...
    @overload
    def getCameraIntrinsics(self, cameraId: CameraBoardSocket, destShape: Size2f, topLeftPixelId: Point2f = ..., bottomRightPixelId: Point2f = ...) -> List[List[float]]: ...
    @overload
    def getCameraIntrinsics(self, cameraId: CameraBoardSocket, destShape: Tuple[int,int], topLeftPixelId: Point2f = ..., bottomRightPixelId: Point2f = ...) -> List[List[float]]: ...
    def getCameraToImuExtrinsics(self, cameraId: CameraBoardSocket, useSpecTranslation: bool = ...) -> List[List[float]]: ...
    def getCameraTranslationVector(self, srcCamera: CameraBoardSocket, dstCamera: CameraBoardSocket, useSpecTranslation: bool = ...) -> List[float]: ...
    def getDefaultIntrinsics(self, cameraId: CameraBoardSocket) -> Tuple[List[List[float]],int,int]: ...
    def getDistortionCoefficients(self, cameraId: CameraBoardSocket) -> List[float]: ...
    def getEepromData(self) -> EepromData: ...
    def getFov(self, cameraId: CameraBoardSocket, useSpec: bool = ...) -> float: ...
    def getImuToCameraExtrinsics(self, cameraId: CameraBoardSocket, useSpecTranslation: bool = ...) -> List[List[float]]: ...
    def getLensPosition(self, cameraId: CameraBoardSocket) -> int: ...
    def getStereoLeftCameraId(self) -> CameraBoardSocket: ...
    def getStereoLeftRectificationRotation(self) -> List[List[float]]: ...
    def getStereoRightCameraId(self) -> CameraBoardSocket: ...
    def getStereoRightRectificationRotation(self) -> List[List[float]]: ...
    def setBoardInfo(self, boardName: str, boardRev: str) -> None: ...
    def setCameraExtrinsics(self, srcCameraId: CameraBoardSocket, destCameraId: CameraBoardSocket, rotationMatrix: List[List[float]], translation: List[float], specTranslation: List[float] = ...) -> None: ...
    @overload
    def setCameraIntrinsics(self, cameraId: CameraBoardSocket, intrinsics: List[List[float]], frameSize: Size2f) -> None: ...
    @overload
    def setCameraIntrinsics(self, cameraId: CameraBoardSocket, intrinsics: List[List[float]], width: int, height: int) -> None: ...
    @overload
    def setCameraIntrinsics(self, cameraId: CameraBoardSocket, intrinsics: List[List[float]], frameSize: Tuple[int,int]) -> None: ...
    def setCameraType(self, cameraId: CameraBoardSocket, cameraModel: CameraModel) -> None: ...
    def setDistortionCoefficients(self, cameraId: CameraBoardSocket, distortionCoefficients: List[float]) -> None: ...
    def setFov(self, cameraId: CameraBoardSocket, hfov: float) -> None: ...
    def setImuExtrinsics(self, destCameraId: CameraBoardSocket, rotationMatrix: List[List[float]], translation: List[float], specTranslation: List[float] = ...) -> None: ...
    def setLensPosition(self, cameraId: CameraBoardSocket, lensPosition: int) -> None: ...
    def setStereoLeft(self, cameraId: CameraBoardSocket, rectifiedRotation: List[List[float]]) -> None: ...
    def setStereoRight(self, cameraId: CameraBoardSocket, rectifiedRotation: List[List[float]]) -> None: ...

class CameraBoardSocket:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    AUTO: ClassVar[CameraBoardSocket] = ...
    CAM_A: ClassVar[CameraBoardSocket] = ...
    CAM_B: ClassVar[CameraBoardSocket] = ...
    CAM_C: ClassVar[CameraBoardSocket] = ...
    CAM_D: ClassVar[CameraBoardSocket] = ...
    CAM_E: ClassVar[CameraBoardSocket] = ...
    CAM_F: ClassVar[CameraBoardSocket] = ...
    CAM_G: ClassVar[CameraBoardSocket] = ...
    CAM_H: ClassVar[CameraBoardSocket] = ...
    CENTER: ClassVar[CameraBoardSocket] = ...
    LEFT: ClassVar[CameraBoardSocket] = ...
    RGB: ClassVar[CameraBoardSocket] = ...
    RIGHT: ClassVar[CameraBoardSocket] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CameraControl(Buffer):
    class AntiBandingMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[RawCameraControl.AntiBandingMode] = ...
        MAINS_50_HZ: ClassVar[RawCameraControl.AntiBandingMode] = ...
        MAINS_60_HZ: ClassVar[RawCameraControl.AntiBandingMode] = ...
        OFF: ClassVar[RawCameraControl.AntiBandingMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class AutoFocusMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[RawCameraControl.AutoFocusMode] = ...
        CONTINUOUS_PICTURE: ClassVar[RawCameraControl.AutoFocusMode] = ...
        CONTINUOUS_VIDEO: ClassVar[RawCameraControl.AutoFocusMode] = ...
        EDOF: ClassVar[RawCameraControl.AutoFocusMode] = ...
        MACRO: ClassVar[RawCameraControl.AutoFocusMode] = ...
        OFF: ClassVar[RawCameraControl.AutoFocusMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class AutoWhiteBalanceMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        CLOUDY_DAYLIGHT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        DAYLIGHT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        FLUORESCENT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        INCANDESCENT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        OFF: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        SHADE: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        TWILIGHT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        WARM_FLUORESCENT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Command:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AE_AUTO: ClassVar[RawCameraControl.Command] = ...
        AE_LOCK: ClassVar[RawCameraControl.Command] = ...
        AE_MANUAL: ClassVar[RawCameraControl.Command] = ...
        AE_REGION: ClassVar[RawCameraControl.Command] = ...
        AE_TARGET_FPS_RANGE: ClassVar[RawCameraControl.Command] = ...
        AF_MODE: ClassVar[RawCameraControl.Command] = ...
        AF_REGION: ClassVar[RawCameraControl.Command] = ...
        AF_TRIGGER: ClassVar[RawCameraControl.Command] = ...
        ANTIBANDING_MODE: ClassVar[RawCameraControl.Command] = ...
        AWB_LOCK: ClassVar[RawCameraControl.Command] = ...
        AWB_MODE: ClassVar[RawCameraControl.Command] = ...
        BRIGHTNESS: ClassVar[RawCameraControl.Command] = ...
        CAPTURE_INTENT: ClassVar[RawCameraControl.Command] = ...
        CHROMA_DENOISE: ClassVar[RawCameraControl.Command] = ...
        CONTRAST: ClassVar[RawCameraControl.Command] = ...
        CONTROL_MODE: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_CAPTURE: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_CAPT_MODE: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_EXP_BRACKETS: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_USECASE: ClassVar[RawCameraControl.Command] = ...
        EFFECT_MODE: ClassVar[RawCameraControl.Command] = ...
        EXPOSURE_COMPENSATION: ClassVar[RawCameraControl.Command] = ...
        FRAME_DURATION: ClassVar[RawCameraControl.Command] = ...
        LUMA_DENOISE: ClassVar[RawCameraControl.Command] = ...
        MOVE_LENS: ClassVar[RawCameraControl.Command] = ...
        NOISE_REDUCTION_STRENGTH: ClassVar[RawCameraControl.Command] = ...
        RESOLUTION: ClassVar[RawCameraControl.Command] = ...
        SATURATION: ClassVar[RawCameraControl.Command] = ...
        SCENE_MODE: ClassVar[RawCameraControl.Command] = ...
        SENSITIVITY: ClassVar[RawCameraControl.Command] = ...
        SHARPNESS: ClassVar[RawCameraControl.Command] = ...
        START_STREAM: ClassVar[RawCameraControl.Command] = ...
        STILL_CAPTURE: ClassVar[RawCameraControl.Command] = ...
        STOP_STREAM: ClassVar[RawCameraControl.Command] = ...
        STREAM_FORMAT: ClassVar[RawCameraControl.Command] = ...
        WB_COLOR_TEMP: ClassVar[RawCameraControl.Command] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class EffectMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AQUA: ClassVar[RawCameraControl.EffectMode] = ...
        BLACKBOARD: ClassVar[RawCameraControl.EffectMode] = ...
        MONO: ClassVar[RawCameraControl.EffectMode] = ...
        NEGATIVE: ClassVar[RawCameraControl.EffectMode] = ...
        OFF: ClassVar[RawCameraControl.EffectMode] = ...
        POSTERIZE: ClassVar[RawCameraControl.EffectMode] = ...
        SEPIA: ClassVar[RawCameraControl.EffectMode] = ...
        SOLARIZE: ClassVar[RawCameraControl.EffectMode] = ...
        WHITEBOARD: ClassVar[RawCameraControl.EffectMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FrameSyncMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        INPUT: ClassVar[RawCameraControl.FrameSyncMode] = ...
        OFF: ClassVar[RawCameraControl.FrameSyncMode] = ...
        OUTPUT: ClassVar[RawCameraControl.FrameSyncMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SceneMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        ACTION: ClassVar[RawCameraControl.SceneMode] = ...
        BARCODE: ClassVar[RawCameraControl.SceneMode] = ...
        BEACH: ClassVar[RawCameraControl.SceneMode] = ...
        CANDLELIGHT: ClassVar[RawCameraControl.SceneMode] = ...
        FACE_PRIORITY: ClassVar[RawCameraControl.SceneMode] = ...
        FIREWORKS: ClassVar[RawCameraControl.SceneMode] = ...
        LANDSCAPE: ClassVar[RawCameraControl.SceneMode] = ...
        NIGHT: ClassVar[RawCameraControl.SceneMode] = ...
        NIGHT_PORTRAIT: ClassVar[RawCameraControl.SceneMode] = ...
        PARTY: ClassVar[RawCameraControl.SceneMode] = ...
        PORTRAIT: ClassVar[RawCameraControl.SceneMode] = ...
        SNOW: ClassVar[RawCameraControl.SceneMode] = ...
        SPORTS: ClassVar[RawCameraControl.SceneMode] = ...
        STEADYPHOTO: ClassVar[RawCameraControl.SceneMode] = ...
        SUNSET: ClassVar[RawCameraControl.SceneMode] = ...
        THEATRE: ClassVar[RawCameraControl.SceneMode] = ...
        UNSUPPORTED: ClassVar[RawCameraControl.SceneMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self) -> None: ...
    def getCaptureStill(self) -> bool: ...
    def setAntiBandingMode(self, mode: RawCameraControl.AntiBandingMode) -> None: ...
    def setAutoExposureCompensation(self, compensation: int) -> None: ...
    def setAutoExposureEnable(self) -> None: ...
    def setAutoExposureLock(self, lock: bool) -> None: ...
    def setAutoExposureRegion(self, startX: int, startY: int, width: int, height: int) -> None: ...
    def setAutoFocusLensRange(self, infinityPosition: int, macroPosition: int) -> None: ...
    def setAutoFocusMode(self, mode: RawCameraControl.AutoFocusMode) -> None: ...
    def setAutoFocusRegion(self, startX: int, startY: int, width: int, height: int) -> None: ...
    def setAutoFocusTrigger(self) -> None: ...
    def setAutoWhiteBalanceLock(self, lock: bool) -> None: ...
    def setAutoWhiteBalanceMode(self, mode: RawCameraControl.AutoWhiteBalanceMode) -> None: ...
    def setBrightness(self, value: int) -> None: ...
    def setCaptureStill(self, capture: bool) -> None: ...
    def setChromaDenoise(self, value: int) -> None: ...
    def setContrast(self, value: int) -> None: ...
    def setEffectMode(self, mode: RawCameraControl.EffectMode) -> None: ...
    def setExternalTrigger(self, numFramesBurst: int, numFramesDiscard: int) -> None: ...
    def setFrameSyncMode(self, mode: RawCameraControl.FrameSyncMode) -> None: ...
    def setLumaDenoise(self, value: int) -> None: ...
    def setManualExposure(self, exposureTimeUs: int, sensitivityIso: int) -> None: ...
    def setManualFocus(self, lensPosition: int) -> None: ...
    def setManualWhiteBalance(self, colorTemperatureK: int) -> None: ...
    def setSaturation(self, value: int) -> None: ...
    def setSceneMode(self, mode: RawCameraControl.SceneMode) -> None: ...
    def setSharpness(self, value: int) -> None: ...
    def setStartStreaming(self) -> None: ...
    def setStopStreaming(self) -> None: ...

class CameraImageOrientation:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    AUTO: ClassVar[CameraImageOrientation] = ...
    HORIZONTAL_MIRROR: ClassVar[CameraImageOrientation] = ...
    NORMAL: ClassVar[CameraImageOrientation] = ...
    ROTATE_180_DEG: ClassVar[CameraImageOrientation] = ...
    VERTICAL_FLIP: ClassVar[CameraImageOrientation] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CameraInfo:
    cameraType: CameraModel
    distortionCoeff: List[float]
    extrinsics: Extrinsics
    height: int
    intrinsicMatrix: List[List[float]]
    specHfovDeg: float
    width: int
    def __init__(self) -> None: ...

class CameraModel:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    Equirectangular: ClassVar[CameraModel] = ...
    Fisheye: ClassVar[CameraModel] = ...
    Perspective: ClassVar[CameraModel] = ...
    RadialDivision: ClassVar[CameraModel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class CameraProperties:
    hasAutofocus: bool
    height: int
    orientation: CameraImageOrientation
    sensorName: str
    socket: CameraBoardSocket
    supportedTypes: List[CameraSensorType]
    width: int
    def __init__(self) -> None: ...

class CameraSensorType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    COLOR: ClassVar[CameraSensorType] = ...
    MONO: ClassVar[CameraSensorType] = ...
    THERMAL: ClassVar[CameraSensorType] = ...
    TOF: ClassVar[CameraSensorType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class ChipTemperature:
    average: float
    css: float
    dss: float
    mss: float
    upa: float
    def __init__(self) -> None: ...

class Clock:
    def __init__(self, *args, **kwargs) -> None: ...
    def now(self) -> datetime.timedelta: ...

class ColorCameraProperties:
    class ColorOrder:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        BGR: ClassVar[ColorCameraProperties.ColorOrder] = ...
        RGB: ClassVar[ColorCameraProperties.ColorOrder] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SensorResolution:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        THE_1080_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_1200_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_12_MP: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_13_MP: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_4_K: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_5_MP: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_720_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        THE_800_P: ClassVar[ColorCameraProperties.SensorResolution] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    boardSocket: CameraBoardSocket
    colorOrder: ColorCameraProperties.ColorOrder
    fps: float
    initialControl: RawCameraControl
    interleaved: bool
    previewHeight: int
    previewWidth: int
    resolution: ColorCameraProperties.SensorResolution
    sensorCropX: float
    sensorCropY: float
    stillHeight: int
    stillWidth: int
    videoHeight: int
    videoWidth: int
    def __init__(self, *args, **kwargs) -> None: ...

class CpuUsage:
    average: float
    msTime: int
    def __init__(self) -> None: ...

class DataInputQueue:
    def __init__(self, *args, **kwargs) -> None: ...
    def close(self) -> None: ...
    def getBlocking(self) -> bool: ...
    def getMaxSize(self) -> int: ...
    def getName(self) -> str: ...
    def isClosed(self) -> bool: ...
    @overload
    def send(self, msg: ADatatype) -> None: ...
    @overload
    def send(self, rawMsg: RawBuffer) -> None: ...
    def setBlocking(self, blocking: bool) -> None: ...
    def setMaxSize(self, maxSize: int) -> None: ...

class DataOutputQueue:
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def addCallback(self, callback: function) -> int: ...
    @overload
    def addCallback(self, callback: function) -> int: ...
    @overload
    def addCallback(self, callback: function) -> int: ...
    def close(self) -> None: ...
    def get(self) -> ADatatype: ...
    def getAll(self) -> List[ADatatype]: ...
    def getBlocking(self) -> bool: ...
    def getMaxSize(self) -> int: ...
    def getName(self) -> str: ...
    def has(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def removeCallback(self, callbackId: int) -> bool: ...
    def setBlocking(self, blocking: bool) -> None: ...
    def setMaxSize(self, maxSize: int) -> None: ...
    def tryGet(self) -> ADatatype: ...
    def tryGetAll(self) -> List[ADatatype]: ...

class DetectionNetworkProperties(NeuralNetworkProperties):
    anchorMasks: Dict[str,List[int]]
    anchors: List[float]
    classes: int
    confidenceThreshold: float
    coordinates: int
    iouThreshold: float
    nnFamily: DetectionNetworkType
    def __init__(self, *args, **kwargs) -> None: ...

class DetectionNetworkType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    MOBILENET: ClassVar[DetectionNetworkType] = ...
    YOLO: ClassVar[DetectionNetworkType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Device(DeviceBase):
    class Config:
        preboot: PrebootConfig
        version: OpenVINO.Version
        def __init__(self) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, usb2Mode: bool) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, devInfo: DeviceInfo, usb2Mode: bool = ...) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, devInfo: DeviceInfo, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version = ...) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, usb2Mode: bool = ...) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, deviceDesc: DeviceInfo, usb2Mode: bool = ...) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, deviceDesc: DeviceInfo, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, config: Device.Config) -> None: ...
    @overload
    def __init__(self, config: Device.Config, deviceInfo: DeviceInfo) -> None: ...
    @overload
    def getInputQueue(self, name: str) -> DataInputQueue: ...
    @overload
    def getInputQueue(self, name: str, maxSize: int, blocking: bool = ...) -> DataInputQueue: ...
    def getInputQueueNames(self) -> List[str]: ...
    @overload
    def getOutputQueue(self, name: str) -> DataOutputQueue: ...
    @overload
    def getOutputQueue(self, name: str, maxSize: int, blocking: bool = ...) -> DataOutputQueue: ...
    def getOutputQueueNames(self) -> List[str]: ...
    @overload
    def getQueueEvent(self, queueNames: List[str], timeout: datetime.timedelta = ...) -> str: ...
    @overload
    def getQueueEvent(self, queueName: str, timeout: datetime.timedelta = ...) -> str: ...
    @overload
    def getQueueEvent(self, timeout: datetime.timedelta = ...) -> str: ...
    @overload
    def getQueueEvents(self, queueNames: List[str], maxNumEvents: int = ..., timeout: datetime.timedelta = ...) -> List[str]: ...
    @overload
    def getQueueEvents(self, queueName: str, maxNumEvents: int = ..., timeout: datetime.timedelta = ...) -> List[str]: ...
    @overload
    def getQueueEvents(self, maxNumEvents: int = ..., timeout: datetime.timedelta = ...) -> List[str]: ...

class DeviceBase:
    @overload
    def __init__(self, pipeline: Pipeline) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, usb2Mode: bool) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, devInfo: DeviceInfo, usb2Mode: bool = ...) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, pipeline: Pipeline, devInfo: DeviceInfo, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version = ...) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, usb2Mode: bool = ...) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, deviceDesc: DeviceInfo, usb2Mode: bool = ...) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, deviceInfo: DeviceInfo, maxUsbSpeed: UsbSpeed) -> None: ...
    @overload
    def __init__(self, version: OpenVINO.Version, deviceDesc: DeviceInfo, pathToCmd: str) -> None: ...
    @overload
    def __init__(self, config: Device.Config) -> None: ...
    @overload
    def __init__(self, config: Device.Config, deviceInfo: DeviceInfo) -> None: ...
    def addLogCallback(self, callback) -> int: ...
    def close(self) -> None: ...
    def flashCalibration(self, calibrationDataHandler: CalibrationHandler) -> bool: ...
    def getAllAvailableDevices(self, *args, **kwargs) -> Any: ...
    def getAnyAvailableDevice(self, *args, **kwargs) -> Any: ...
    def getCameraSensorNames(self) -> Dict[CameraBoardSocket,str]: ...
    def getChipTemperature(self) -> ChipTemperature: ...
    def getCmxMemoryUsage(self) -> MemoryInfo: ...
    def getConnectedCameraProperties(self) -> List[CameraProperties]: ...
    def getConnectedCameras(self) -> List[CameraBoardSocket]: ...
    def getDdrMemoryUsage(self) -> MemoryInfo: ...
    def getDeviceByMxId(self, *args, **kwargs) -> Any: ...
    def getDeviceInfo(self) -> DeviceInfo: ...
    def getEmbeddedDeviceBinary(self, *args, **kwargs) -> Any: ...
    def getFirstAvailableDevice(self, *args, **kwargs) -> Any: ...
    def getLeonCssCpuUsage(self) -> CpuUsage: ...
    def getLeonCssHeapUsage(self) -> MemoryInfo: ...
    def getLeonMssCpuUsage(self) -> CpuUsage: ...
    def getLeonMssHeapUsage(self) -> MemoryInfo: ...
    def getLogLevel(self) -> LogLevel: ...
    def getLogOutputLevel(self) -> LogLevel: ...
    def getMxId(self) -> str: ...
    def getSystemInformationLoggingRate(self) -> float: ...
    def getUsbSpeed(self) -> UsbSpeed: ...
    def getXLinkChunkSize(self) -> int: ...
    def isClosed(self) -> bool: ...
    def isPipelineRunning(self) -> bool: ...
    def readCalibration(self) -> CalibrationHandler: ...
    def removeLogCallback(self, callbackId: int) -> bool: ...
    def setLogLevel(self, level: LogLevel) -> None: ...
    def setLogOutputLevel(self, level: LogLevel) -> None: ...
    def setSystemInformationLoggingRate(self, rateHz: float) -> None: ...
    def setXLinkChunkSize(self, sizeBytes: int) -> None: ...
    @overload
    def startPipeline(self) -> None: ...
    @overload
    def startPipeline(self, arg0: Pipeline) -> bool: ...
    def __enter__(self) -> DeviceBase: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class DeviceBootloader:
    class Config:
        appMem: DeviceBootloader.Memory
        network: DeviceBootloader.NetworkConfig
        usb: DeviceBootloader.UsbConfig
        def __init__(self) -> None: ...
        def getDnsAltIPv4(self) -> str: ...
        def getDnsIPv4(self) -> str: ...
        def getIPv4(self) -> str: ...
        def getIPv4Gateway(self) -> str: ...
        def getIPv4Mask(self) -> str: ...
        def getMacAddress(self) -> str: ...
        def getNetworkTimeout(self) -> datetime.timedelta: ...
        def getUsbMaxSpeed(self) -> UsbSpeed: ...
        def getUsbTimeout(self) -> datetime.timedelta: ...
        def isStaticIPV4(self) -> bool: ...
        def setDnsIPv4(self, arg0: str, arg1: str) -> None: ...
        def setDynamicIPv4(self, arg0: str, arg1: str, arg2: str) -> None: ...
        def setMacAddress(self, arg0: str) -> None: ...
        def setNetworkTimeout(self, arg0: datetime.timedelta) -> None: ...
        def setStaticIPv4(self, arg0: str, arg1: str, arg2: str) -> None: ...
        def setUsbMaxSpeed(self, arg0: UsbSpeed) -> None: ...
        def setUsbTimeout(self, arg0: datetime.timedelta) -> None: ...

    class Memory:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[DeviceBootloader.Memory] = ...
        EMMC: ClassVar[DeviceBootloader.Memory] = ...
        FLASH: ClassVar[DeviceBootloader.Memory] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class NetworkConfig:
        ipv4: int
        ipv4Dns: int
        ipv4DnsAlt: int
        ipv4Gateway: int
        ipv4Mask: int
        ipv6: List[int[4]]
        ipv6Dns: List[int[4]]
        ipv6DnsAlt: List[int[4]]
        ipv6Gateway: List[int[4]]
        ipv6Prefix: int
        mac: List[int[6]]
        staticIpv4: bool
        staticIpv6: bool
        timeoutMs: int
        def __init__(self) -> None: ...

    class Section:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        APPLICATION: ClassVar[DeviceBootloader.Section] = ...
        AUTO: ClassVar[DeviceBootloader.Section] = ...
        BOOTLOADER: ClassVar[DeviceBootloader.Section] = ...
        BOOTLOADER_CONFIG: ClassVar[DeviceBootloader.Section] = ...
        HEADER: ClassVar[DeviceBootloader.Section] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Type:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[DeviceBootloader.Type] = ...
        NETWORK: ClassVar[DeviceBootloader.Type] = ...
        USB: ClassVar[DeviceBootloader.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class UsbConfig:
        maxUsbSpeed: int
        pid: int
        timeoutMs: int
        vid: int
        def __init__(self) -> None: ...

    class Version:
        __hash__: ClassVar[None] = ...
        @overload
        def __init__(self, v: str) -> None: ...
        @overload
        def __init__(self, major: int, minor: int, patch: int) -> None: ...
        def __eq__(self, arg0: DeviceBootloader.Version) -> bool: ...
        def __gt__(self, arg0: DeviceBootloader.Version) -> bool: ...
        def __lt__(self, arg0: DeviceBootloader.Version) -> bool: ...
    @overload
    def __init__(self, devInfo: DeviceInfo, allowFlashingBootloader: bool = ...) -> None: ...
    @overload
    def __init__(self, devInfo: DeviceInfo, pathToCmd: str, allowFlashingBootloader: bool = ...) -> None: ...
    def bootMemory(self, fw: List[int]) -> None: ...
    def bootUsbRomBootloader(self) -> None: ...
    def close(self) -> None: ...
    def createDepthaiApplicationPackage(self, *args, **kwargs) -> Any: ...
    @overload
    def flash(self, progressCallback: Callable[[float],None], pipeline: Pipeline, compress: bool = ...) -> Tuple[bool,str]: ...
    @overload
    def flash(self, pipeline: Pipeline, compress: bool = ...) -> Tuple[bool,str]: ...
    @overload
    def flashBootloader(self, progressCallback: Callable[[float],None], path: str = ...) -> Tuple[bool,str]: ...
    @overload
    def flashBootloader(self, memory: DeviceBootloader.Memory, type: DeviceBootloader.Type, progressCallback: Callable[[float],None], path: str = ...) -> Tuple[bool,str]: ...
    def flashConfig(self, config: DeviceBootloader.Config, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> Tuple[bool,str]: ...
    def flashConfigClear(self, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> Tuple[bool,str]: ...
    def flashConfigData(self, configData: json, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> Tuple[bool,str]: ...
    def flashConfigFile(self, configData: str, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> Tuple[bool,str]: ...
    @overload
    def flashDepthaiApplicationPackage(self, progressCallback: Callable[[float],None], package: List[int]) -> Tuple[bool,str]: ...
    @overload
    def flashDepthaiApplicationPackage(self, package: List[int]) -> Tuple[bool,str]: ...
    def getAllAvailableDevices(self, *args, **kwargs) -> Any: ...
    def getEmbeddedBootloaderBinary(self, *args, **kwargs) -> Any: ...
    def getEmbeddedBootloaderVersion(self, *args, **kwargs) -> Any: ...
    def getFirstAvailableDevice(self, *args, **kwargs) -> Any: ...
    def getType(self) -> DeviceBootloader.Type: ...
    def getVersion(self) -> DeviceBootloader.Version: ...
    def isAllowedFlashingBootloader(self) -> bool: ...
    def isEmbeddedVersion(self) -> bool: ...
    def readConfig(self, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> DeviceBootloader.Config: ...
    def readConfigData(self, memory: DeviceBootloader.Memory = ..., type: DeviceBootloader.Type = ...) -> json: ...
    def saveDepthaiApplicationPackage(self, *args, **kwargs) -> Any: ...
    def __enter__(self) -> DeviceBootloader: ...
    def __exit__(self, arg0: object, arg1: object, arg2: object) -> None: ...

class DeviceDesc:
    name: str
    platform: XLinkPlatform
    protocol: XLinkProtocol
    def __init__(self) -> None: ...

class DeviceInfo:
    desc: DeviceDesc
    state: XLinkDeviceState
    def __init__(self) -> None: ...
    def getMxId(self) -> str: ...

class EdgeDetectorConfig(Buffer):
    def __init__(self) -> None: ...
    def getConfigData(self) -> EdgeDetectorConfigData: ...
    def setSobelFilterKernels(self, horizontalKernel: List[List[int]], verticalKernel: List[List[int]]) -> None: ...

class EdgeDetectorConfigData:
    sobelFilterHorizontalKernel: Used for horizontal gradiant computation in 3x3 Sobel filter Format
    sobelFilterVerticalKernel: Used for vertical gradiant computation in 3x3 Sobel filter Format
    def __init__(self) -> None: ...

class EdgeDetectorProperties:
    initialConfig: RawEdgeDetectorConfig
    inputConfigSync: bool
    numFramesPool: int
    outputFrameSize: int
    def __init__(self, *args, **kwargs) -> None: ...

class EepromData:
    boardName: str
    boardRev: str
    cameraData: Dict[CameraBoardSocket,CameraInfo]
    imuExtrinsics: Extrinsics
    stereoRectificationData: StereoRectification
    version: int
    def __init__(self) -> None: ...

class Extrinsics:
    rotationMatrix: List[List[float]]
    specTranslation: Point3f
    toCameraSocket: CameraBoardSocket
    translation: Point3f
    def __init__(self) -> None: ...

class FeatureTrackerConfig(Buffer):
    class CornerDetector:
        class Thresholds:
            decreaseFactor: float
            increaseFactor: float
            initialValue: float
            max: float
            min: float
            def __init__(self) -> None: ...
    
        class Type:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            HARRIS: ClassVar[RawFeatureTrackerConfig.CornerDetector.Type] = ...
            SHI_THOMASI: ClassVar[RawFeatureTrackerConfig.CornerDetector.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        cellGridDimension: int
        enableSobel: bool
        enableSorting: bool
        numMaxFeatures: int
        numTargetFeatures: int
        thresholds: RawFeatureTrackerConfig.CornerDetector.Thresholds
        type: RawFeatureTrackerConfig.CornerDetector.Type
        def __init__(self) -> None: ...

    class FeatureMaintainer:
        enable: bool
        lostFeatureErrorThreshold: float
        minimumDistanceBetweenFeatures: float
        trackedFeatureThreshold: float
        def __init__(self) -> None: ...

    class MotionEstimator:
        class OpticalFlow:
            epsilon: float
            maxIterations: int
            pyramidLevels: int
            searchWindowHeight: int
            searchWindowWidth: int
            def __init__(self) -> None: ...
    
        class Type:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            HW_MOTION_ESTIMATION: ClassVar[RawFeatureTrackerConfig.MotionEstimator.Type] = ...
            LUCAS_KANADE_OPTICAL_FLOW: ClassVar[RawFeatureTrackerConfig.MotionEstimator.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        enable: bool
        opticalFlow: RawFeatureTrackerConfig.MotionEstimator.OpticalFlow
        type: RawFeatureTrackerConfig.MotionEstimator.Type
        def __init__(self) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: RawFeatureTrackerConfig) -> None: ...
    def get(self) -> RawFeatureTrackerConfig: ...
    def set(self, config: RawFeatureTrackerConfig) -> None: ...
    @overload
    def setCornerDetector(self, cornerDetector: RawFeatureTrackerConfig.CornerDetector.Type) -> None: ...
    @overload
    def setCornerDetector(self, config: RawFeatureTrackerConfig.CornerDetector) -> None: ...
    @overload
    def setFeatureMaintainer(self, enable: bool) -> None: ...
    @overload
    def setFeatureMaintainer(self, config: RawFeatureTrackerConfig.FeatureMaintainer) -> None: ...
    def setHwMotionEstimation(self) -> None: ...
    @overload
    def setMotionEstimator(self, enable: bool) -> None: ...
    @overload
    def setMotionEstimator(self, config: RawFeatureTrackerConfig.MotionEstimator) -> None: ...
    def setNumTargetFeatures(self, numTargetFeatures: int) -> None: ...
    @overload
    def setOpticalFlow(self) -> None: ...
    @overload
    def setOpticalFlow(self, config: RawFeatureTrackerConfig.MotionEstimator.OpticalFlow) -> None: ...

class FeatureTrackerProperties:
    initialConfig: RawFeatureTrackerConfig
    inputConfigSync: bool
    numMemorySlices: int
    numShaves: int
    def __init__(self, *args, **kwargs) -> None: ...

class GlobalProperties:
    cameraTuningBlobSize: Optional[int]
    cameraTuningBlobUri: str
    leonOsFrequencyHz: float
    leonRtFrequencyHz: float
    pipelineName: Optional[str]
    pipelineVersion: Optional[str]
    xlinkChunkSize: int
    def __init__(self, *args, **kwargs) -> None: ...

class IMUData(Buffer):
    packets: List[IMUPacket]
    def __init__(self) -> None: ...

class IMUPacket:
    acceleroMeter: IMUReportAccelerometer
    gyroscope: IMUReportGyroscope
    magneticField: IMUReportMagneticField
    rotationVector: IMUReportRotationVectorWAcc
    def __init__(self) -> None: ...

class IMUProperties:
    batchReportThreshold: int
    imuSensors: List[IMUSensorConfig]
    maxBatchReports: int
    def __init__(self, *args, **kwargs) -> None: ...

class IMUReport:
    class Accuracy:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        HIGH: ClassVar[IMUReport.Accuracy] = ...
        LOW: ClassVar[IMUReport.Accuracy] = ...
        MEDIUM: ClassVar[IMUReport.Accuracy] = ...
        UNRELIABLE: ClassVar[IMUReport.Accuracy] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    accuracy: IMUReport.Accuracy
    sequence: int
    timestamp: Timestamp
    def __init__(self) -> None: ...

class IMUReportAccelerometer(IMUReport):
    x: float
    y: float
    z: float
    def __init__(self) -> None: ...

class IMUReportGyroscope(IMUReport):
    x: float
    y: float
    z: float
    def __init__(self) -> None: ...

class IMUReportMagneticField(IMUReport):
    x: float
    y: float
    z: float
    def __init__(self) -> None: ...

class IMUReportRotationVectorWAcc(IMUReport):
    i: float
    j: float
    k: float
    real: float
    rotationVectorAccuracy: float
    def __init__(self) -> None: ...

class IMUSensor:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    ACCELEROMETER: ClassVar[IMUSensor] = ...
    ACCELEROMETER_RAW: ClassVar[IMUSensor] = ...
    ARVR_STABILIZED_GAME_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    ARVR_STABILIZED_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    GAME_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    GEOMAGNETIC_ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    GRAVITY: ClassVar[IMUSensor] = ...
    GYROSCOPE_CALIBRATED: ClassVar[IMUSensor] = ...
    GYROSCOPE_RAW: ClassVar[IMUSensor] = ...
    GYROSCOPE_UNCALIBRATED: ClassVar[IMUSensor] = ...
    LINEAR_ACCELERATION: ClassVar[IMUSensor] = ...
    MAGNETOMETER_CALIBRATED: ClassVar[IMUSensor] = ...
    MAGNETOMETER_RAW: ClassVar[IMUSensor] = ...
    MAGNETOMETER_UNCALIBRATED: ClassVar[IMUSensor] = ...
    ROTATION_VECTOR: ClassVar[IMUSensor] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class IMUSensorConfig:
    changeSensitivity: int
    reportRate: int
    sensitivityEnabled: bool
    sensitivityRelative: bool
    sensorId: IMUSensor
    def __init__(self) -> None: ...

class ImageManipConfig(Buffer):
    def __init__(self) -> None: ...
    def getCropConfig(self) -> RawImageManipConfig.CropConfig: ...
    def getCropXMax(self) -> float: ...
    def getCropXMin(self) -> float: ...
    def getCropYMax(self) -> float: ...
    def getCropYMin(self) -> float: ...
    def getFormatConfig(self) -> RawImageManipConfig.FormatConfig: ...
    def getResizeConfig(self) -> RawImageManipConfig.ResizeConfig: ...
    def getResizeHeight(self) -> int: ...
    def getResizeWidth(self) -> int: ...
    def isResizeThumbnail(self) -> bool: ...
    def setCenterCrop(self, ratio: float, whRatio: float = ...) -> None: ...
    def setCropRect(self, coordinates: Tuple[float,float,float,float]) -> None: ...
    def setCropRotatedRect(self, rr: RotatedRect, normalizedCoords: bool = ...) -> None: ...
    def setFrameType(self, name: RawImgFrame.Type) -> None: ...
    def setHorizontalFlip(self, flip: bool) -> None: ...
    def setKeepAspectRatio(self, keep: bool) -> None: ...
    @overload
    def setResize(self, w: int, h: int) -> None: ...
    @overload
    def setResize(self, size: Tuple[int,int]) -> None: ...
    @overload
    def setResizeThumbnail(self, w: int, h: int, bgRed: int = ..., bgGreen: int = ..., bgBlue: int = ...) -> None: ...
    @overload
    def setResizeThumbnail(self, size: Tuple[int,int], bgRed: int = ..., bgGreen: int = ..., bgBlue: int = ...) -> None: ...
    def setReusePreviousImage(self, reuse: bool) -> None: ...
    def setRotationDegrees(self, deg: float) -> None: ...
    def setRotationRadians(self, rad: float) -> None: ...
    def setSkipCurrentImage(self, skip: bool) -> None: ...
    def setWarpBorderFillColor(self, red: int, green: int, blue: int) -> None: ...
    def setWarpBorderReplicatePixels(self) -> None: ...
    def setWarpTransformFourPoints(self, pt: List[Point2f], normalizedCoords: bool) -> None: ...
    def setWarpTransformMatrix3x3(self, mat: List[float]) -> None: ...

class ImgDetection:
    confidence: float
    label: int
    xmax: float
    xmin: float
    ymax: float
    ymin: float
    def __init__(self) -> None: ...

class ImgDetections(Buffer):
    detections: List[ImgDetection]
    def __init__(self) -> None: ...

class ImgFrame(Buffer):
    class Specs:
        bytesPP: int
        height: int
        p1Offset: int
        p2Offset: int
        p3Offset: int
        stride: int
        type: RawImgFrame.Type
        width: int
        def __init__(self) -> None: ...

    class Type:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        BGR888i: ClassVar[RawImgFrame.Type] = ...
        BGR888p: ClassVar[RawImgFrame.Type] = ...
        BGRF16F16F16i: ClassVar[RawImgFrame.Type] = ...
        BGRF16F16F16p: ClassVar[RawImgFrame.Type] = ...
        BITSTREAM: ClassVar[RawImgFrame.Type] = ...
        GRAY8: ClassVar[RawImgFrame.Type] = ...
        GRAYF16: ClassVar[RawImgFrame.Type] = ...
        HDR: ClassVar[RawImgFrame.Type] = ...
        LUT16: ClassVar[RawImgFrame.Type] = ...
        LUT2: ClassVar[RawImgFrame.Type] = ...
        LUT4: ClassVar[RawImgFrame.Type] = ...
        NONE: ClassVar[RawImgFrame.Type] = ...
        NV12: ClassVar[RawImgFrame.Type] = ...
        NV21: ClassVar[RawImgFrame.Type] = ...
        PACK10: ClassVar[RawImgFrame.Type] = ...
        PACK12: ClassVar[RawImgFrame.Type] = ...
        RAW10: ClassVar[RawImgFrame.Type] = ...
        RAW12: ClassVar[RawImgFrame.Type] = ...
        RAW14: ClassVar[RawImgFrame.Type] = ...
        RAW16: ClassVar[RawImgFrame.Type] = ...
        RAW8: ClassVar[RawImgFrame.Type] = ...
        RGB161616: ClassVar[RawImgFrame.Type] = ...
        RGB888i: ClassVar[RawImgFrame.Type] = ...
        RGB888p: ClassVar[RawImgFrame.Type] = ...
        RGBA8888: ClassVar[RawImgFrame.Type] = ...
        RGBF16F16F16i: ClassVar[RawImgFrame.Type] = ...
        RGBF16F16F16p: ClassVar[RawImgFrame.Type] = ...
        YUV400p: ClassVar[RawImgFrame.Type] = ...
        YUV420p: ClassVar[RawImgFrame.Type] = ...
        YUV422i: ClassVar[RawImgFrame.Type] = ...
        YUV422p: ClassVar[RawImgFrame.Type] = ...
        YUV444i: ClassVar[RawImgFrame.Type] = ...
        YUV444p: ClassVar[RawImgFrame.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    def __init__(self) -> None: ...
    def getCategory(self) -> int: ...
    def getCvFrame(self) -> object: ...
    def getExposureTime(self) -> int: ...
    def getFrame(self, copy: bool = ...) -> numpy.ndarray: ...
    def getHeight(self) -> int: ...
    def getInstanceNum(self) -> int: ...
    def getLensPosition(self) -> int: ...
    def getSensitivity(self) -> int: ...
    def getSequenceNum(self) -> int: ...
    def getTimestamp(self) -> datetime.timedelta: ...
    def getTimestampDevice(self) -> datetime.timedelta: ...
    def getType(self) -> RawImgFrame.Type: ...
    def getWidth(self) -> int: ...
    def setCategory(self, category: int) -> None: ...
    def setFrame(self, array: numpy.ndarray) -> None: ...
    def setHeight(self, height: int) -> None: ...
    def setInstanceNum(self, instance: int) -> None: ...
    def setSequenceNum(self, seq: int) -> None: ...
    @overload
    def setSize(self, width: int, height: int) -> None: ...
    @overload
    def setSize(self, sizer: Tuple[int,int]) -> None: ...
    def setTimestamp(self, timestamp: datetime.timedelta) -> None: ...
    def setType(self, type: RawImgFrame.Type) -> None: ...
    def setWidth(self, width: int) -> None: ...

class LogLevel:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    CRITICAL: ClassVar[LogLevel] = ...
    DEBUG: ClassVar[LogLevel] = ...
    ERR: ClassVar[LogLevel] = ...
    INFO: ClassVar[LogLevel] = ...
    OFF: ClassVar[LogLevel] = ...
    TRACE: ClassVar[LogLevel] = ...
    WARN: ClassVar[LogLevel] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MedianFilter:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    KERNEL_3x3: ClassVar[MedianFilter] = ...
    KERNEL_5x5: ClassVar[MedianFilter] = ...
    KERNEL_7x7: ClassVar[MedianFilter] = ...
    MEDIAN_OFF: ClassVar[MedianFilter] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MemoryInfo:
    remaining: int
    total: int
    used: int
    def __init__(self) -> None: ...

class MonoCameraProperties:
    class SensorResolution:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        THE_400_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_480_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_720_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        THE_800_P: ClassVar[MonoCameraProperties.SensorResolution] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    boardSocket: CameraBoardSocket
    fps: float
    initialControl: RawCameraControl
    resolution: MonoCameraProperties.SensorResolution
    def __init__(self, *args, **kwargs) -> None: ...

class NNData(Buffer):
    def __init__(self) -> None: ...
    def getAllLayerNames(self) -> List[str]: ...
    def getAllLayers(self) -> List[TensorInfo]: ...
    def getFirstLayerFp16(self) -> List[float]: ...
    def getFirstLayerInt32(self) -> List[int]: ...
    def getFirstLayerUInt8(self) -> List[int]: ...
    def getLayer(self, name: str, tensor: TensorInfo) -> bool: ...
    def getLayerDatatype(self, name: str, datatype: TensorInfo.DataType) -> bool: ...
    def getLayerFp16(self, name: str) -> List[float]: ...
    def getLayerInt32(self, name: str) -> List[int]: ...
    def getLayerUInt8(self, name: str) -> List[int]: ...
    def hasLayer(self, name: str) -> bool: ...
    @overload
    def setLayer(self, name: str, data: numpy.ndarray[numpy.uint8]) -> None: ...
    @overload
    def setLayer(self, name: str, data: List[int]) -> None: ...
    @overload
    def setLayer(self, name: str, data: List[float]) -> None: ...
    @overload
    def setLayer(self, name: str, data: List[float]) -> None: ...

class NeuralNetworkProperties:
    blobSize: Optional[int]
    blobUri: str
    numFrames: int
    numNCEPerThread: int
    numThreads: int
    def __init__(self, *args, **kwargs) -> None: ...

class Node:
    class Connection:
        inputId: int
        inputName: str
        outputId: int
        outputName: str
        def __init__(self, *args, **kwargs) -> None: ...

    class Id:
        def __init__(self, *args, **kwargs) -> None: ...

    class Input:
        class Type:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            MReceiver: ClassVar[Node.Input.Type] = ...
            SReceiver: ClassVar[Node.Input.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        def __init__(self, *args, **kwargs) -> None: ...
        def getBlocking(self) -> bool: ...
        def getQueueSize(self) -> int: ...
        def setBlocking(self, blocking: bool) -> None: ...
        def setQueueSize(self, size: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def type(self) -> Node.Input.Type: ...

    class InputMap:
        def __init__(self, *args, **kwargs) -> None: ...
        def items(self) -> Iterator: ...
        def __bool__(self) -> bool: ...
        def __contains__(self, arg0: str) -> bool: ...
        def __delitem__(self, arg0: str) -> None: ...
        def __getitem__(self, arg0: str) -> Node.Input: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __setitem__(self, arg0: str, arg1: Node.Input) -> None: ...

    class Output:
        class Type:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            MSender: ClassVar[Node.Output.Type] = ...
            SSender: ClassVar[Node.Output.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        def __init__(self, *args, **kwargs) -> None: ...
        def canConnect(self, input: Node.Input) -> bool: ...
        def getConnections(self) -> List[Node.Connection]: ...
        def link(self, input: Node.Input) -> None: ...
        def unlink(self, input: Node.Input) -> None: ...

    class OutputMap:
        def __init__(self, *args, **kwargs) -> None: ...
        def items(self) -> Iterator: ...
        def __bool__(self) -> bool: ...
        def __contains__(self, arg0: str) -> bool: ...
        def __delitem__(self, arg0: str) -> None: ...
        def __getitem__(self, arg0: str) -> Node.Output: ...
        def __iter__(self) -> Iterator: ...
        def __len__(self) -> int: ...
        def __setitem__(self, arg0: str, arg1: Node.Output) -> None: ...
    def __init__(self, *args, **kwargs) -> None: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    @overload
    def getInputRefs(self) -> List[Node.Input]: ...
    @overload
    def getInputRefs(self) -> List[Node.Input]: ...
    def getInputs(self) -> List[Node.Input]: ...
    def getName(self) -> str: ...
    @overload
    def getOutputRefs(self) -> List[Node.Output]: ...
    @overload
    def getOutputRefs(self) -> List[Node.Output]: ...
    def getOutputs(self) -> List[Node.Output]: ...
    @overload
    def getParentPipeline(self) -> Pipeline: ...
    @overload
    def getParentPipeline(self) -> Pipeline: ...
    @property
    def id(self) -> int: ...

class ObjectTrackerProperties:
    detectionLabelsToTrack: List[int]
    maxObjectsToTrack: int
    trackerIdAssigmentPolicy: TrackerIdAssigmentPolicy
    trackerThreshold: float
    trackerType: TrackerType
    def __init__(self, *args, **kwargs) -> None: ...

class OpenVINO:
    class Version:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        VERSION_2020_3: ClassVar[OpenVINO.Version] = ...
        VERSION_2020_4: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_1: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_2: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_3: ClassVar[OpenVINO.Version] = ...
        VERSION_2021_4: ClassVar[OpenVINO.Version] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    VERSION_2020_3: ClassVar[OpenVINO.Version] = ...
    VERSION_2020_4: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_1: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_2: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_3: ClassVar[OpenVINO.Version] = ...
    VERSION_2021_4: ClassVar[OpenVINO.Version] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    def areVersionsBlobCompatible(self, *args, **kwargs) -> Any: ...
    def getBlobLatestSupportedVersion(self, *args, **kwargs) -> Any: ...
    def getBlobSupportedVersions(self, *args, **kwargs) -> Any: ...
    def getVersionName(self, *args, **kwargs) -> Any: ...
    def getVersions(self, *args, **kwargs) -> Any: ...
    def parseVersionName(self, *args, **kwargs) -> Any: ...

class Pipeline:
    def __init__(self) -> None: ...
    @overload
    def create(self, arg0: typing.Type[node.ColorCamera]) -> node.ColorCamera: ...
    @overload
    def create(self, arg0: typing.Type[node.EdgeDetector]) -> node.EdgeDetector: ...
    @overload
    def create(self, arg0: typing.Type[node.FeatureTracker]) -> node.FeatureTracker: ...
    @overload
    def create(self, arg0: typing.Type[node.IMU]) -> node.IMU: ...
    @overload
    def create(self, arg0: typing.Type[node.ImageManip]) -> node.ImageManip: ...
    @overload
    def create(self, arg0: typing.Type[node.MobileNetDetectionNetwork]) -> node.MobileNetDetectionNetwork: ...
    @overload
    def create(self, arg0: typing.Type[node.MobileNetSpatialDetectionNetwork]) -> node.MobileNetSpatialDetectionNetwork: ...
    @overload
    def create(self, arg0: typing.Type[node.MonoCamera]) -> node.MonoCamera: ...
    @overload
    def create(self, arg0: typing.Type[node.NeuralNetwork]) -> node.NeuralNetwork: ...
    @overload
    def create(self, arg0: typing.Type[node.ObjectTracker]) -> node.ObjectTracker: ...
    @overload
    def create(self, arg0: typing.Type[node.SPIIn]) -> node.SPIIn: ...
    @overload
    def create(self, arg0: typing.Type[node.SPIOut]) -> node.SPIOut: ...
    @overload
    def create(self, arg0: typing.Type[node.SpatialLocationCalculator]) -> node.SpatialLocationCalculator: ...
    @overload
    def create(self, arg0: typing.Type[node.StereoDepth]) -> node.StereoDepth: ...
    @overload
    def create(self, arg0: typing.Type[node.SystemLogger]) -> node.SystemLogger: ...
    @overload
    def create(self, arg0: typing.Type[node.UVC]) -> node.UVC: ...
    @overload
    def create(self, arg0: typing.Type[node.VideoEncoder]) -> node.VideoEncoder: ...
    @overload
    def create(self, arg0: typing.Type[node.XLinkIn]) -> node.XLinkIn: ...
    @overload
    def create(self, arg0: typing.Type[node.XLinkOut]) -> node.XLinkOut: ...
    @overload
    def create(self, arg0: typing.Type[node.YoloDetectionNetwork]) -> node.YoloDetectionNetwork: ...
    @overload
    def create(self, arg0: typing.Type[node.YoloSpatialDetectionNetwork]) -> node.YoloSpatialDetectionNetwork: ...
    def createColorCamera(self) -> node.ColorCamera: ...
    def createEdgeDetector(self) -> node.EdgeDetector: ...
    def createFeatureTracker(self) -> node.FeatureTracker: ...
    def createIMU(self) -> node.IMU: ...
    def createImageManip(self) -> node.ImageManip: ...
    def createMobileNetDetectionNetwork(self) -> node.MobileNetDetectionNetwork: ...
    def createMobileNetSpatialDetectionNetwork(self) -> node.MobileNetSpatialDetectionNetwork: ...
    def createMonoCamera(self) -> node.MonoCamera: ...
    def createNeuralNetwork(self) -> node.NeuralNetwork: ...
    def createObjectTracker(self) -> node.ObjectTracker: ...
    def createSPIIn(self) -> node.SPIIn: ...
    def createSPIOut(self) -> node.SPIOut: ...
    def createSpatialLocationCalculator(self) -> node.SpatialLocationCalculator: ...
    def createStereoDepth(self) -> node.StereoDepth: ...
    def createSystemLogger(self) -> node.SystemLogger: ...
    def createUVC(self) -> node.UVC: ...
    def createVideoEncoder(self) -> node.VideoEncoder: ...
    def createXLinkIn(self) -> node.XLinkIn: ...
    def createXLinkOut(self) -> node.XLinkOut: ...
    def createYoloDetectionNetwork(self) -> node.YoloDetectionNetwork: ...
    def createYoloSpatialDetectionNetwork(self) -> node.YoloSpatialDetectionNetwork: ...
    @overload
    def getAllNodes(self) -> List[Node]: ...
    @overload
    def getAllNodes(self) -> List[Node]: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    @overload
    def getAssetManager(self) -> AssetManager: ...
    def getCalibrationData(self) -> CalibrationHandler: ...
    def getConnectionMap(self) -> Dict[int,Set[Node.Connection]]: ...
    def getConnections(self) -> List[Node.Connection]: ...
    def getDeviceConfig(self) -> Device.Config: ...
    def getGlobalProperties(self) -> GlobalProperties: ...
    @overload
    def getNode(self, arg0: int) -> Node: ...
    @overload
    def getNode(self, arg0: int) -> Node: ...
    def getNodeMap(self) -> Dict[int,Node]: ...
    def getOpenVINOVersion(self) -> OpenVINO.Version: ...
    def getRequiredOpenVINOVersion(self) -> Optional[OpenVINO.Version]: ...
    def link(self, arg0: Node.Output, arg1: Node.Input) -> None: ...
    def remove(self, node: Node) -> None: ...
    def setCalibrationData(self, calibrationDataHandler: CalibrationHandler) -> None: ...
    def setCameraTuningBlobPath(self, path: str) -> None: ...
    def setOpenVINOVersion(self, version: OpenVINO.Version = ...) -> None: ...
    def setXLinkChunkSize(self, sizeBytes: int) -> None: ...
    def unlink(self, arg0: Node.Output, arg1: Node.Input) -> None: ...

class Point2f:
    x: float
    y: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float) -> None: ...

class Point3f:
    x: float
    y: float
    z: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None: ...

class PrebootConfig:
    class USB:
        flashBootedPid: int
        flashBootedVid: int
        maxSpeed: UsbSpeed
        pid: int
        vid: int
        def __init__(self) -> None: ...
    usb: PrebootConfig.USB
    watchdogTimeoutMs: Optional[int]
    def __init__(self) -> None: ...

class ProcessorType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    LEON_CSS: ClassVar[ProcessorType] = ...
    LEON_MSS: ClassVar[ProcessorType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RawBuffer:
    data: numpy.ndarray[numpy.uint8]
    def __init__(self) -> None: ...

class RawCameraControl(RawBuffer):
    class AntiBandingMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[RawCameraControl.AntiBandingMode] = ...
        MAINS_50_HZ: ClassVar[RawCameraControl.AntiBandingMode] = ...
        MAINS_60_HZ: ClassVar[RawCameraControl.AntiBandingMode] = ...
        OFF: ClassVar[RawCameraControl.AntiBandingMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class AutoFocusMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[RawCameraControl.AutoFocusMode] = ...
        CONTINUOUS_PICTURE: ClassVar[RawCameraControl.AutoFocusMode] = ...
        CONTINUOUS_VIDEO: ClassVar[RawCameraControl.AutoFocusMode] = ...
        EDOF: ClassVar[RawCameraControl.AutoFocusMode] = ...
        MACRO: ClassVar[RawCameraControl.AutoFocusMode] = ...
        OFF: ClassVar[RawCameraControl.AutoFocusMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class AutoWhiteBalanceMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AUTO: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        CLOUDY_DAYLIGHT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        DAYLIGHT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        FLUORESCENT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        INCANDESCENT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        OFF: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        SHADE: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        TWILIGHT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        WARM_FLUORESCENT: ClassVar[RawCameraControl.AutoWhiteBalanceMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class Command:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AE_AUTO: ClassVar[RawCameraControl.Command] = ...
        AE_LOCK: ClassVar[RawCameraControl.Command] = ...
        AE_MANUAL: ClassVar[RawCameraControl.Command] = ...
        AE_REGION: ClassVar[RawCameraControl.Command] = ...
        AE_TARGET_FPS_RANGE: ClassVar[RawCameraControl.Command] = ...
        AF_MODE: ClassVar[RawCameraControl.Command] = ...
        AF_REGION: ClassVar[RawCameraControl.Command] = ...
        AF_TRIGGER: ClassVar[RawCameraControl.Command] = ...
        ANTIBANDING_MODE: ClassVar[RawCameraControl.Command] = ...
        AWB_LOCK: ClassVar[RawCameraControl.Command] = ...
        AWB_MODE: ClassVar[RawCameraControl.Command] = ...
        BRIGHTNESS: ClassVar[RawCameraControl.Command] = ...
        CAPTURE_INTENT: ClassVar[RawCameraControl.Command] = ...
        CHROMA_DENOISE: ClassVar[RawCameraControl.Command] = ...
        CONTRAST: ClassVar[RawCameraControl.Command] = ...
        CONTROL_MODE: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_CAPTURE: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_CAPT_MODE: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_EXP_BRACKETS: ClassVar[RawCameraControl.Command] = ...
        CUSTOM_USECASE: ClassVar[RawCameraControl.Command] = ...
        EFFECT_MODE: ClassVar[RawCameraControl.Command] = ...
        EXPOSURE_COMPENSATION: ClassVar[RawCameraControl.Command] = ...
        FRAME_DURATION: ClassVar[RawCameraControl.Command] = ...
        LUMA_DENOISE: ClassVar[RawCameraControl.Command] = ...
        MOVE_LENS: ClassVar[RawCameraControl.Command] = ...
        NOISE_REDUCTION_STRENGTH: ClassVar[RawCameraControl.Command] = ...
        RESOLUTION: ClassVar[RawCameraControl.Command] = ...
        SATURATION: ClassVar[RawCameraControl.Command] = ...
        SCENE_MODE: ClassVar[RawCameraControl.Command] = ...
        SENSITIVITY: ClassVar[RawCameraControl.Command] = ...
        SHARPNESS: ClassVar[RawCameraControl.Command] = ...
        START_STREAM: ClassVar[RawCameraControl.Command] = ...
        STILL_CAPTURE: ClassVar[RawCameraControl.Command] = ...
        STOP_STREAM: ClassVar[RawCameraControl.Command] = ...
        STREAM_FORMAT: ClassVar[RawCameraControl.Command] = ...
        WB_COLOR_TEMP: ClassVar[RawCameraControl.Command] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class EffectMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        AQUA: ClassVar[RawCameraControl.EffectMode] = ...
        BLACKBOARD: ClassVar[RawCameraControl.EffectMode] = ...
        MONO: ClassVar[RawCameraControl.EffectMode] = ...
        NEGATIVE: ClassVar[RawCameraControl.EffectMode] = ...
        OFF: ClassVar[RawCameraControl.EffectMode] = ...
        POSTERIZE: ClassVar[RawCameraControl.EffectMode] = ...
        SEPIA: ClassVar[RawCameraControl.EffectMode] = ...
        SOLARIZE: ClassVar[RawCameraControl.EffectMode] = ...
        WHITEBOARD: ClassVar[RawCameraControl.EffectMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class FrameSyncMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        INPUT: ClassVar[RawCameraControl.FrameSyncMode] = ...
        OFF: ClassVar[RawCameraControl.FrameSyncMode] = ...
        OUTPUT: ClassVar[RawCameraControl.FrameSyncMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class SceneMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        ACTION: ClassVar[RawCameraControl.SceneMode] = ...
        BARCODE: ClassVar[RawCameraControl.SceneMode] = ...
        BEACH: ClassVar[RawCameraControl.SceneMode] = ...
        CANDLELIGHT: ClassVar[RawCameraControl.SceneMode] = ...
        FACE_PRIORITY: ClassVar[RawCameraControl.SceneMode] = ...
        FIREWORKS: ClassVar[RawCameraControl.SceneMode] = ...
        LANDSCAPE: ClassVar[RawCameraControl.SceneMode] = ...
        NIGHT: ClassVar[RawCameraControl.SceneMode] = ...
        NIGHT_PORTRAIT: ClassVar[RawCameraControl.SceneMode] = ...
        PARTY: ClassVar[RawCameraControl.SceneMode] = ...
        PORTRAIT: ClassVar[RawCameraControl.SceneMode] = ...
        SNOW: ClassVar[RawCameraControl.SceneMode] = ...
        SPORTS: ClassVar[RawCameraControl.SceneMode] = ...
        STEADYPHOTO: ClassVar[RawCameraControl.SceneMode] = ...
        SUNSET: ClassVar[RawCameraControl.SceneMode] = ...
        THEATRE: ClassVar[RawCameraControl.SceneMode] = ...
        UNSUPPORTED: ClassVar[RawCameraControl.SceneMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    aeLockMode: bool
    afRegion: Any
    antiBandingMode: RawCameraControl.AntiBandingMode
    autoFocusMode: RawCameraControl.AutoFocusMode
    awbLockMode: bool
    awbMode: RawCameraControl.AutoWhiteBalanceMode
    brightness: int
    chromaDenoise: int
    cmdMask: int
    contrast: int
    effectMode: RawCameraControl.EffectMode
    expCompensation: int
    expManual: Any
    lensPosition: int
    lumaDenoise: int
    saturation: int
    sceneMode: RawCameraControl.SceneMode
    sharpness: int
    wbColorTemp: int
    def __init__(self) -> None: ...
    def clearCommand(self, arg0: RawCameraControl.Command) -> None: ...
    def getCommand(self, arg0: RawCameraControl.Command) -> bool: ...
    def setCommand(self, arg0: RawCameraControl.Command, arg1: bool) -> None: ...

class RawEdgeDetectorConfig(RawBuffer):
    config: EdgeDetectorConfigData
    def __init__(self) -> None: ...

class RawFeatureTrackerConfig(RawBuffer):
    class CornerDetector:
        class Thresholds:
            decreaseFactor: float
            increaseFactor: float
            initialValue: float
            max: float
            min: float
            def __init__(self) -> None: ...
    
        class Type:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            HARRIS: ClassVar[RawFeatureTrackerConfig.CornerDetector.Type] = ...
            SHI_THOMASI: ClassVar[RawFeatureTrackerConfig.CornerDetector.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        cellGridDimension: int
        enableSobel: bool
        enableSorting: bool
        numMaxFeatures: int
        numTargetFeatures: int
        thresholds: RawFeatureTrackerConfig.CornerDetector.Thresholds
        type: RawFeatureTrackerConfig.CornerDetector.Type
        def __init__(self) -> None: ...

    class FeatureMaintainer:
        enable: bool
        lostFeatureErrorThreshold: float
        minimumDistanceBetweenFeatures: float
        trackedFeatureThreshold: float
        def __init__(self) -> None: ...

    class MotionEstimator:
        class OpticalFlow:
            epsilon: float
            maxIterations: int
            pyramidLevels: int
            searchWindowHeight: int
            searchWindowWidth: int
            def __init__(self) -> None: ...
    
        class Type:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            HW_MOTION_ESTIMATION: ClassVar[RawFeatureTrackerConfig.MotionEstimator.Type] = ...
            LUCAS_KANADE_OPTICAL_FLOW: ClassVar[RawFeatureTrackerConfig.MotionEstimator.Type] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        enable: bool
        opticalFlow: RawFeatureTrackerConfig.MotionEstimator.OpticalFlow
        type: RawFeatureTrackerConfig.MotionEstimator.Type
        def __init__(self) -> None: ...
    cornerDetector: RawFeatureTrackerConfig.CornerDetector
    featureMaintainer: RawFeatureTrackerConfig.FeatureMaintainer
    motionEstimator: RawFeatureTrackerConfig.MotionEstimator
    def __init__(self) -> None: ...

class RawIMUData(RawBuffer):
    packets: List[IMUPacket]
    def __init__(self) -> None: ...

class RawImageManipConfig(RawBuffer):
    class CropConfig:
        cropRatio: float
        cropRect: RawImageManipConfig.CropRect
        cropRotatedRect: RotatedRect
        enableCenterCropRectangle: bool
        enableRotatedRect: bool
        normalizedCoords: bool
        widthHeightAspectRatio: float
        def __init__(self) -> None: ...

    class CropRect:
        xmax: float
        xmin: float
        ymax: float
        ymin: float
        def __init__(self) -> None: ...

    class FormatConfig:
        flipHorizontal: bool
        type: RawImgFrame.Type
        def __init__(self) -> None: ...

    class ResizeConfig:
        bgBlue: str
        bgGreen: str
        bgRed: str
        enableRotation: bool
        enableWarp4pt: bool
        enableWarpMatrix: bool
        height: int
        keepAspectRatio: bool
        lockAspectRatioFill: bool
        normalizedCoords: bool
        rotationAngleDeg: float
        warpBorderReplicate: bool
        warpFourPoints: List[Point2f]
        warpMatrix3x3: List[float]
        width: int
        def __init__(self) -> None: ...
    cropConfig: RawImageManipConfig.CropConfig
    enableCrop: bool
    enableFormat: bool
    enableResize: bool
    formatConfig: RawImageManipConfig.FormatConfig
    resizeConfig: RawImageManipConfig.ResizeConfig
    def __init__(self) -> None: ...

class RawImgDetections(RawBuffer):
    detections: List[ImgDetection]
    def __init__(self) -> None: ...

class RawImgFrame(RawBuffer):
    class Specs:
        bytesPP: int
        height: int
        p1Offset: int
        p2Offset: int
        p3Offset: int
        stride: int
        type: RawImgFrame.Type
        width: int
        def __init__(self) -> None: ...

    class Type:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        BGR888i: ClassVar[RawImgFrame.Type] = ...
        BGR888p: ClassVar[RawImgFrame.Type] = ...
        BGRF16F16F16i: ClassVar[RawImgFrame.Type] = ...
        BGRF16F16F16p: ClassVar[RawImgFrame.Type] = ...
        BITSTREAM: ClassVar[RawImgFrame.Type] = ...
        GRAY8: ClassVar[RawImgFrame.Type] = ...
        GRAYF16: ClassVar[RawImgFrame.Type] = ...
        HDR: ClassVar[RawImgFrame.Type] = ...
        LUT16: ClassVar[RawImgFrame.Type] = ...
        LUT2: ClassVar[RawImgFrame.Type] = ...
        LUT4: ClassVar[RawImgFrame.Type] = ...
        NONE: ClassVar[RawImgFrame.Type] = ...
        NV12: ClassVar[RawImgFrame.Type] = ...
        NV21: ClassVar[RawImgFrame.Type] = ...
        PACK10: ClassVar[RawImgFrame.Type] = ...
        PACK12: ClassVar[RawImgFrame.Type] = ...
        RAW10: ClassVar[RawImgFrame.Type] = ...
        RAW12: ClassVar[RawImgFrame.Type] = ...
        RAW14: ClassVar[RawImgFrame.Type] = ...
        RAW16: ClassVar[RawImgFrame.Type] = ...
        RAW8: ClassVar[RawImgFrame.Type] = ...
        RGB161616: ClassVar[RawImgFrame.Type] = ...
        RGB888i: ClassVar[RawImgFrame.Type] = ...
        RGB888p: ClassVar[RawImgFrame.Type] = ...
        RGBA8888: ClassVar[RawImgFrame.Type] = ...
        RGBF16F16F16i: ClassVar[RawImgFrame.Type] = ...
        RGBF16F16F16p: ClassVar[RawImgFrame.Type] = ...
        YUV400p: ClassVar[RawImgFrame.Type] = ...
        YUV420p: ClassVar[RawImgFrame.Type] = ...
        YUV422i: ClassVar[RawImgFrame.Type] = ...
        YUV422p: ClassVar[RawImgFrame.Type] = ...
        YUV444i: ClassVar[RawImgFrame.Type] = ...
        YUV444p: ClassVar[RawImgFrame.Type] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    category: int
    fb: RawImgFrame.Specs
    instanceNum: int
    sequenceNum: int
    ts: float
    tsDevice: float
    def __init__(self) -> None: ...

class RawNNData(RawBuffer):
    batchSize: int
    tensors: List[TensorInfo]
    def __init__(self) -> None: ...

class RawSpatialImgDetections(RawBuffer):
    detections: List[SpatialImgDetection]
    def __init__(self) -> None: ...

class RawStereoDepthConfig(RawBuffer):
    class AlgorithmControl:
        enableExtended: bool
        enableLeftRightCheck: bool
        enableSubpixel: bool
        leftRightCheckThreshold: int
        subpixelFractionalBits: Number of fractional bits for subpixel mode. Valid values
        def __init__(self) -> None: ...

    class CensusTransform:
        class KernelSize:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            AUTO: ClassVar[RawStereoDepthConfig.CensusTransform.KernelSize] = ...
            KERNEL_5x5: ClassVar[RawStereoDepthConfig.CensusTransform.KernelSize] = ...
            KERNEL_7x7: ClassVar[RawStereoDepthConfig.CensusTransform.KernelSize] = ...
            KERNEL_7x9: ClassVar[RawStereoDepthConfig.CensusTransform.KernelSize] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
        enableMeanMode: bool
        kernelMask: Census transform mask, default
        kernelSize: RawStereoDepthConfig.CensusTransform.KernelSize
        threshold: int
        def __init__(self) -> None: ...

    class CostAggregation:
        divisionFactor: int
        horizontalPenaltyCostP1: int
        horizontalPenaltyCostP2: int
        verticalPenaltyCostP1: int
        verticalPenaltyCostP2: int
        def __init__(self) -> None: ...

    class CostMatching:
        class DisparityWidth:
            __doc__: ClassVar[str] = ...  # read-only
            __members__: ClassVar[dict] = ...  # read-only
            DISPARITY_64: ClassVar[RawStereoDepthConfig.CostMatching.DisparityWidth] = ...
            DISPARITY_96: ClassVar[RawStereoDepthConfig.CostMatching.DisparityWidth] = ...
            __entries: ClassVar[dict] = ...
            def __init__(self, value: int) -> None: ...
            def __eq__(self, other: object) -> bool: ...
            def __getstate__(self) -> int: ...
            def __hash__(self) -> int: ...
            def __index__(self) -> int: ...
            def __int__(self) -> int: ...
            def __ne__(self, other: object) -> bool: ...
            def __setstate__(self, state: int) -> None: ...
            @property
            def name(self) -> str: ...
            @property
            def value(self) -> int: ...
    
        class LinearEquationParameters:
            alpha: int
            beta: int
            threshold: int
            def __init__(self) -> None: ...
        confidenceThreshold: int
        disparityWidth: RawStereoDepthConfig.CostMatching.DisparityWidth
        enableCompanding: bool
        invalidDisparityValue: int
        linearEquationParameters: RawStereoDepthConfig.CostMatching.LinearEquationParameters
        def __init__(self) -> None: ...

    class MedianFilter:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        KERNEL_3x3: ClassVar[MedianFilter] = ...
        KERNEL_5x5: ClassVar[MedianFilter] = ...
        KERNEL_7x7: ClassVar[MedianFilter] = ...
        MEDIAN_OFF: ClassVar[MedianFilter] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class PostProcessing:
        bilateralSigmaValue: int
        median: MedianFilter
        def __init__(self) -> None: ...
    algorithmControl: Controls the flow of stereo algorithm
    censusTransform: RawStereoDepthConfig.CensusTransform
    costAggregation: RawStereoDepthConfig.CostAggregation
    costMatching: RawStereoDepthConfig.CostMatching
    postProcessing: RawStereoDepthConfig.PostProcessing
    def __init__(self) -> None: ...

class RawSystemInformation(RawBuffer):
    chipTemperature: ChipTemperature
    cmxMemoryUsage: MemoryInfo
    ddrMemoryUsage: MemoryInfo
    leonCssCpuUsage: CpuUsage
    leonCssMemoryUsage: MemoryInfo
    leonMssCpuUsage: CpuUsage
    leonMssMemoryUsage: MemoryInfo
    def __init__(self) -> None: ...

class RawTrackedFeatures(RawBuffer):
    trackedFeatures: List[TrackedFeature]
    def __init__(self) -> None: ...

class RawTracklets(RawBuffer):
    tracklets: List[Tracklet]
    def __init__(self) -> None: ...

class Rect:
    height: float
    width: float
    x: float
    y: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float, arg2: float, arg3: float) -> None: ...
    @overload
    def __init__(self, arg0: Point2f, arg1: Point2f) -> None: ...
    @overload
    def __init__(self, arg0: Point2f, arg1: Size2f) -> None: ...
    def area(self) -> float: ...
    def bottomRight(self) -> Point2f: ...
    def contains(self, arg0: Point2f) -> bool: ...
    def denormalize(self, width: int, height: int) -> Rect: ...
    def empty(self) -> bool: ...
    def isNormalized(self) -> bool: ...
    def normalize(self, width: int, height: int) -> Rect: ...
    def size(self) -> Size2f: ...
    def topLeft(self) -> Point2f: ...

class RotatedRect:
    angle: float
    center: Point2f
    size: Size2f
    def __init__(self) -> None: ...

class SPIInProperties:
    busId: int
    maxDataSize: int
    numFrames: int
    streamName: str
    def __init__(self, *args, **kwargs) -> None: ...

class SPIOutProperties:
    busId: int
    streamName: str
    def __init__(self, *args, **kwargs) -> None: ...

class ScriptProperties:
    processor: ProcessorType
    scriptName: str
    scriptUri: str
    def __init__(self, *args, **kwargs) -> None: ...

class Size2f:
    height: float
    width: float
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: float, arg1: float) -> None: ...

class SpatialDetectionNetworkProperties(DetectionNetworkProperties):
    depthThresholds: SpatialLocationCalculatorConfigThresholds
    detectedBBScaleFactor: float
    def __init__(self, *args, **kwargs) -> None: ...

class SpatialImgDetection(ImgDetection):
    spatialCoordinates: Point3f
    def __init__(self) -> None: ...

class SpatialImgDetections(Buffer):
    detections: List[SpatialImgDetection]
    def __init__(self) -> None: ...

class SpatialLocationCalculatorAlgorithm:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    AVERAGE: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    MAX: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    MIN: ClassVar[SpatialLocationCalculatorAlgorithm] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class SpatialLocationCalculatorConfig(Buffer):
    def __init__(self) -> None: ...
    def addROI(self, ROI: SpatialLocationCalculatorConfigData) -> None: ...
    def getConfigData(self) -> List[SpatialLocationCalculatorConfigData]: ...
    def setROIs(self, ROIs: List[SpatialLocationCalculatorConfigData]) -> None: ...

class SpatialLocationCalculatorConfigData:
    calculationAlgorithm: Calculation method used to obtain spatial locations. Average
    depthThresholds: SpatialLocationCalculatorConfigThresholds
    roi: Rect
    def __init__(self) -> None: ...

class SpatialLocationCalculatorConfigThresholds:
    lowerThreshold: int
    upperThreshold: int
    def __init__(self) -> None: ...

class SpatialLocationCalculatorData(Buffer):
    spatialLocations: List[SpatialLocations]
    def __init__(self) -> None: ...
    def getSpatialLocations(self) -> List[SpatialLocations]: ...

class SpatialLocationCalculatorProperties:
    inputConfigSync: bool
    roiConfig: Any
    def __init__(self, *args, **kwargs) -> None: ...

class SpatialLocations:
    config: SpatialLocationCalculatorConfigData
    depthAverage: float
    depthAveragePixelCount: int
    depthMax: int
    depthMin: int
    spatialCoordinates: Spatial coordinates
    def __init__(self) -> None: ...

class StereoDepthConfig(Buffer):
    def __init__(self) -> None: ...
    def get(self) -> RawStereoDepthConfig: ...
    def getBilateralFilterSigma(self) -> int: ...
    def getConfidenceThreshold(self) -> int: ...
    def getLeftRightCheckThreshold(self) -> int: ...
    def getMaxDisparity(self) -> float: ...
    def getMedianFilter(self) -> MedianFilter: ...
    def set(self, config: RawStereoDepthConfig) -> None: ...
    def setBilateralFilterSigma(self, sigma: int) -> None: ...
    def setConfidenceThreshold(self, confThr: int) -> None: ...
    def setExtendedDisparity(self, enable: bool) -> None: ...
    def setLeftRightCheck(self, enable: bool) -> None: ...
    def setLeftRightCheckThreshold(self, sigma: int) -> None: ...
    def setMedianFilter(self, median: MedianFilter) -> None: ...
    def setSubpixel(self, enable: bool) -> None: ...

class StereoDepthProperties:
    class MedianFilter:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        KERNEL_3x3: ClassVar[MedianFilter] = ...
        KERNEL_5x5: ClassVar[MedianFilter] = ...
        KERNEL_7x7: ClassVar[MedianFilter] = ...
        MEDIAN_OFF: ClassVar[MedianFilter] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    depthAlign: Any
    depthAlignCamera: CameraBoardSocket
    height: Optional[int]
    initialConfig: RawStereoDepthConfig
    inputConfigSync: bool
    mesh: Any
    outHeight: Optional[int]
    outKeepAspectRatio: bool
    outWidth: Optional[int]
    rectifyEdgeFillColor: int
    width: Optional[int]
    def __init__(self, *args, **kwargs) -> None: ...

class StereoRectification:
    leftCameraSocket: CameraBoardSocket
    rectifiedRotationLeft: List[List[float]]
    rectifiedRotationRight: List[List[float]]
    rightCameraSocket: CameraBoardSocket
    def __init__(self) -> None: ...

class SystemInformation(Buffer):
    chipTemperature: ChipTemperature
    cmxMemoryUsage: MemoryInfo
    ddrMemoryUsage: MemoryInfo
    leonCssCpuUsage: CpuUsage
    leonCssMemoryUsage: MemoryInfo
    leonMssCpuUsage: CpuUsage
    leonMssMemoryUsage: MemoryInfo
    def __init__(self) -> None: ...

class SystemLoggerProperties:
    rateHz: float
    def __init__(self, *args, **kwargs) -> None: ...

class TensorInfo:
    class DataType:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        FP16: ClassVar[TensorInfo.DataType] = ...
        FP32: ClassVar[TensorInfo.DataType] = ...
        I8: ClassVar[TensorInfo.DataType] = ...
        INT: ClassVar[TensorInfo.DataType] = ...
        U8F: ClassVar[TensorInfo.DataType] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class StorageOrder:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        C: ClassVar[TensorInfo.StorageOrder] = ...
        CHW: ClassVar[TensorInfo.StorageOrder] = ...
        CN: ClassVar[TensorInfo.StorageOrder] = ...
        CWH: ClassVar[TensorInfo.StorageOrder] = ...
        H: ClassVar[TensorInfo.StorageOrder] = ...
        HCW: ClassVar[TensorInfo.StorageOrder] = ...
        HWC: ClassVar[TensorInfo.StorageOrder] = ...
        NC: ClassVar[TensorInfo.StorageOrder] = ...
        NCHW: ClassVar[TensorInfo.StorageOrder] = ...
        NHCW: ClassVar[TensorInfo.StorageOrder] = ...
        NHWC: ClassVar[TensorInfo.StorageOrder] = ...
        W: ClassVar[TensorInfo.StorageOrder] = ...
        WCH: ClassVar[TensorInfo.StorageOrder] = ...
        WHC: ClassVar[TensorInfo.StorageOrder] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    dataType: TensorInfo.DataType
    dims: List[int]
    name: str
    numDimensions: int
    offset: int
    order: TensorInfo.StorageOrder
    strides: List[int]
    def __init__(self) -> None: ...

class Timestamp:
    nsec: int
    sec: int
    def __init__(self) -> None: ...
    def get(self) -> datetime.timedelta: ...

class TrackedFeature:
    id: int
    position: Point2f
    def __init__(self) -> None: ...

class TrackedFeatures(Buffer):
    trackedFeatures: List[TrackedFeature]
    def __init__(self) -> None: ...

class TrackerIdAssigmentPolicy:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    SMALLEST_ID: ClassVar[TrackerIdAssigmentPolicy] = ...
    UNIQUE_ID: ClassVar[TrackerIdAssigmentPolicy] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class TrackerType:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    SHORT_TERM_IMAGELESS: ClassVar[TrackerType] = ...
    SHORT_TERM_KCF: ClassVar[TrackerType] = ...
    ZERO_TERM_COLOR_HISTOGRAM: ClassVar[TrackerType] = ...
    ZERO_TERM_IMAGELESS: ClassVar[TrackerType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Tracklet:
    class TrackingStatus:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        LOST: ClassVar[Tracklet.TrackingStatus] = ...
        NEW: ClassVar[Tracklet.TrackingStatus] = ...
        REMOVED: ClassVar[Tracklet.TrackingStatus] = ...
        TRACKED: ClassVar[Tracklet.TrackingStatus] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    id: int
    label: int
    roi: Rect
    spatialCoordinates: Point3f
    srcImgDetection: ImgDetection
    status: Tracklet.TrackingStatus
    def __init__(self) -> None: ...

class Tracklets(Buffer):
    tracklets: List[Tracklet]
    def __init__(self) -> None: ...

class UsbSpeed:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    FULL: ClassVar[UsbSpeed] = ...
    HIGH: ClassVar[UsbSpeed] = ...
    LOW: ClassVar[UsbSpeed] = ...
    SUPER: ClassVar[UsbSpeed] = ...
    SUPER_PLUS: ClassVar[UsbSpeed] = ...
    UNKNOWN: ClassVar[UsbSpeed] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class VideoEncoderProperties:
    class Profile:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        H264_BASELINE: ClassVar[VideoEncoderProperties.Profile] = ...
        H264_HIGH: ClassVar[VideoEncoderProperties.Profile] = ...
        H264_MAIN: ClassVar[VideoEncoderProperties.Profile] = ...
        H265_MAIN: ClassVar[VideoEncoderProperties.Profile] = ...
        MJPEG: ClassVar[VideoEncoderProperties.Profile] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...

    class RateControlMode:
        __doc__: ClassVar[str] = ...  # read-only
        __members__: ClassVar[dict] = ...  # read-only
        CBR: ClassVar[VideoEncoderProperties.RateControlMode] = ...
        VBR: ClassVar[VideoEncoderProperties.RateControlMode] = ...
        __entries: ClassVar[dict] = ...
        def __init__(self, value: int) -> None: ...
        def __eq__(self, other: object) -> bool: ...
        def __getstate__(self) -> int: ...
        def __hash__(self) -> int: ...
        def __index__(self) -> int: ...
        def __int__(self) -> int: ...
        def __ne__(self, other: object) -> bool: ...
        def __setstate__(self, state: int) -> None: ...
        @property
        def name(self) -> str: ...
        @property
        def value(self) -> int: ...
    bitrate: int
    keyframeFrequency: int
    maxBitrate: int
    numBFrames: int
    numFramesPool: int
    profile: VideoEncoderProperties.Profile
    quality: int
    rateCtrlMode: VideoEncoderProperties.RateControlMode
    def __init__(self, *args, **kwargs) -> None: ...

class XLinkConnection:
    @overload
    def __init__(self, arg0: DeviceInfo, arg1: List[int]) -> None: ...
    @overload
    def __init__(self, arg0: DeviceInfo, arg1: str) -> None: ...
    @overload
    def __init__(self, arg0: DeviceInfo) -> None: ...
    def bootBootloader(self, *args, **kwargs) -> Any: ...
    def getAllConnectedDevices(self, *args, **kwargs) -> Any: ...
    def getDeviceByMxId(self, *args, **kwargs) -> Any: ...
    def getFirstDevice(self, *args, **kwargs) -> Any: ...

class XLinkDeviceState:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    X_LINK_ANY_STATE: ClassVar[XLinkDeviceState] = ...
    X_LINK_BOOTED: ClassVar[XLinkDeviceState] = ...
    X_LINK_BOOTLOADER: ClassVar[XLinkDeviceState] = ...
    X_LINK_FLASH_BOOTED: ClassVar[XLinkDeviceState] = ...
    X_LINK_UNBOOTED: ClassVar[XLinkDeviceState] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class XLinkError(RuntimeError): ...

class XLinkPlatform:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    X_LINK_ANY_PLATFORM: ClassVar[XLinkPlatform] = ...
    X_LINK_MYRIAD_2: ClassVar[XLinkPlatform] = ...
    X_LINK_MYRIAD_X: ClassVar[XLinkPlatform] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class XLinkProtocol:
    __doc__: ClassVar[str] = ...  # read-only
    __members__: ClassVar[dict] = ...  # read-only
    X_LINK_ANY_PROTOCOL: ClassVar[XLinkProtocol] = ...
    X_LINK_IPC: ClassVar[XLinkProtocol] = ...
    X_LINK_NMB_OF_PROTOCOLS: ClassVar[XLinkProtocol] = ...
    X_LINK_PCIE: ClassVar[XLinkProtocol] = ...
    X_LINK_TCP_IP: ClassVar[XLinkProtocol] = ...
    X_LINK_USB_CDC: ClassVar[XLinkProtocol] = ...
    X_LINK_USB_VSC: ClassVar[XLinkProtocol] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class XLinkReadError(XLinkError): ...

class XLinkWriteError(XLinkError): ...
